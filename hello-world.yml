---
#ddd:
#value_objects: Many objects have no conceptual identity.  These objects describe characteristics of a thing.
#entities:
#aggregates:
#root entities:

# Link to an aggregate root entity >=>
# Link within an aggregate to a non-root entity >->
# Events persisted |>
state:
aggregate:
resource:
requests:
responses:
commands:
queries:
events:

Revision:
  logicalClock: Int!
  localTime: EpochTime

Order: @aggregateRoot
  id: OrderId! @isUnique
  revision: Revision!
  lines: [OrderLine!]
OrderLine:
  id: OrderLineId! @isPartUnique
  productId: >=> Product.id
  price: Money!
  quantity: OrderQuantity

# Function
RepriceOrderLine: /api/orders/{orderId}/order-lines/{orderLineId}/price-modification
  -> Order.id
  -> OrderLine.id
  ~> RepricingRequest
  => OrderLineRepricingResponse
  |> OrderLinePriceChanged
  @invariant(newPrice < OrderLine.price * 0.10 unless managerOverride)

# invariants ?
RepricingRequest:
  newPrice: Money!
  reason: RepricingRational!    # raison d'Ãªtre
  managerOverride: Boolean

RepricingRational:
  | Clearance
  | CustomerLoyalty
  | DamagedItem
  | OtherRepricingRational

OtherRepricingRational: String!

OrderLineRepricingResponse:



# Better? change the price of product "xyz" in my order to x. Does knowing the orderLineId provide value? Can the same product have multiple order lines?
ChangeOrderLinePrice: Order -> Product.id -> Price -> Order
# Events
OrderLinePriceChanged:
  orderId: OrderId!
  orderLineId: OrderLineId!
  updatedPrice: Money!
# Apply
OrderLinePriceChangedApply: state -> orderLinePriceChanged -> state
  {state|state.lines[x].price=updatedPrice when x.orderId=orderId}
HelloWorldCreatedEvent(helloWorldAggregate), state) => HelloWorldState(Some(helloWorldAggregate), HelloWorldStatus.ACTIVE, 1
HelloWorldReplacedEvent(helloWorldId, replacementHelloWorldResource, motivation), state) =>
            HelloWorldState(Some(HelloWorldAggregate(helloWorldId, replacementHelloWorldResource)), HelloWorldStatus.ACTIVE, 1

# Reference from one aggregate to a non-root entity in another aggregate

Abc:
  id: AbcId
  name: AbcName
  orderLines: [>=> AbcOrderLines!]   # maybe better to cache value objects from OrderLine references may not exist later?
    order: Order.id!
    line: OrderLine.id!



AbcName: String @check("")


/api/

-> --> >>=


metadata:
  name
  definition
  units of measure
  contraints
  datatype
  generic element / class word
  versioned vs. non-versioned
  nullability
  relationships
  defaults
  { references, POC }


scalar_types:
  HelloWorldId: String @check("[a-zA-Z0-9\-\.\_\~]{1,128}")
  Name: String @check("[a-zA-Z0-9\-\.\_\~]{1,128}")
  Description: String @check(".{1,2048}")
events:
  | HelloWorldCreated
  | HelloWorldDeleted
  | HelloWorldArchived
  | HelloWorldUnarchived
paths:
  | "/api/hello-worlds": createHelloWorld
  |
serviceCalls:
  | createHelloWorld: ServiceCall[CreateHelloWorldRequest, CreateHelloWorldResponse]
  | archiveHelloWorld(helloWorldId: UUID): ServiceCall[ArchiveHelloWorldRequest, ArchiveHelloWorldResponse]
  | getHelloWorld(helloWorldId: UUID): ServiceCall[NotUsed, GetHelloWorldResponse]
  | getAllHelloWorlds: ServiceCall[NotUsed, GetAllHelloWorldsResponse]
commands:
replies:
type: HelloWorld
  name: String!
  description: String
type: HelloWorldResource
  helloWorldId: HelloWorldId @isUnique @default(CUID)
  helloWorld: HelloWorld
type: HelloWorldAggregate
  helloWorldId: Uuid! @isUnique
  helloWorld: HelloWorld
# All commands include parameters for CorrelationId and SpanId
type: CreateHelloWorldCommand
type: CreateHelloWorldRequest
  helloWorldId: Uuid
  helloWorld: HelloWorld

# The purpose of the SpanId is to function as a distributed tracing span
# identifier. If it is missing the command generates a unique identifier.
# This identifier along with timestamps of
...


notes: Everything is either a value object or an entity. Persistent entity for commands and queries, they may then call the domain aggregate persistent entity. Everything in a different project allows each to scale differently. A smaller cluster also means quicker passivation. JWT fields and asymetric key encryption to provide a symetric key. Use Kafka for notification of revoked tokens. Log'out function.
scalar_types:
  HelloWorldId: String @check("[a-zA-Z0-9\-\.\_\~]{1,128}")
  Name: String @check("[a-zA-Z0-9\-\.\_\~]{1,128}")
  Description: String @check(".{1,2048}")
events:
  | HelloWorldCreated
  | HelloWorldDeleted
  | HelloWorldArchived
  | HelloWorldUnarchived
paths:
  | "/api/hello-worlds": createHelloWorld
  |
serviceCalls:
  | createHelloWorld: ServiceCall[CreateHelloWorldRequest, CreateHelloWorldResponse]
  | archiveHelloWorld(helloWorldId: UUID): ServiceCall[ArchiveHelloWorldRequest, ArchiveHelloWorldResponse]
  | getHelloWorld(helloWorldId: UUID): ServiceCall[NotUsed, GetHelloWorldResponse]
  | getAllHelloWorlds: ServiceCall[NotUsed, GetAllHelloWorldsResponse]
commands:
replies:
type: HelloWorld
  name: String!
  description: String
type: HelloWorldResource
  helloWorldId: HelloWorldId @isUnique @default(CUID)
  helloWorld: HelloWorld
type: HelloWorldAggregate
  helloWorldId: Uuid! @isUnique
  helloWorld: HelloWorld
# All commands include parameters for CorrelationId and SpanId
type: CreateHelloWorldCommand
type: CreateHelloWorldRequest
  helloWorldId: Uuid
  helloWorld: HelloWorld

# The purpose of the SpanId is to function as a distributed tracing span
# identifier. If it is missing the command generates a unique identifier.
# This identifier along with timestamps of
...